%% Marcus
The tool will be developed in Unity, a cross platform game engine. In order to collaborate, the project will be stored in a Git repository. This also allows for version control and the opportunity to revert to previous versions for identification of bugs or if something would corrupt. Since a Unity project does not consist of pure text or code files, additional steps have to be taken in order to avoid merge conflicts or other issues that can arise when collaborating in a version control system. Therefore each developer will have their own scene in Unity and updates to the project will mainly take place as changes to \glossaryword{prefab}{prefabs}, which are reusable objects that can be used as templates.

%% Felix
\subsection{Game Engine and Libraries}
    Unity is a cross-platform game engine and development environment which comes with a plethora of useful tools for developing software that communicate a 3D environment. It is currently the most used game engine, holding a market share of 38\% within the game engine market. From initially being marketed as highly accessible game-engine, it has with time grown into a versatile tool that can be used for a wide range of applications, including animation, simulation, VR, architectural visualisation, and more. With the above in mind, together with the massive amount of high quality documentation available and high number of asset plugins available, we motivate our choice of engine to realise the simulation in. 

%% Felix
\subsection{Modeling}
    We motivate our choice of going with an agent based approach by its ability to capture and convey complex behaviour that otherwise would have required very complex mathematics. Since we "only" need to decide and configure how the agents react to the simulation environment, this will typically be enough to allow us to capture interesting emergent system behaviour that would have required the use of complex differential equations if modeled from a macroscopic perspective using techniques derived from fluid dynamics. 

    %% Felix //Började förkorta till ABM här
    Since our goal is to make a product that can easily convey both statistical information of the simulation as well as the first-hand experience of how the traffic actually will behave in the form of exploring the environment in real- time 3D, this further motivates our decision to go with a ABM approach. While ABM is classified as a microscopic model, it still allows for gathering data from each autonomous agent and aggregating this in the form of statistics. On the other hand, by actually rendering the simulation and each agent in real time, this will allow the user to see the effect of the parameters they supplied and set for the environment. This could for example be in the form of observing a crossing, or following one specific agent. 

    %% Felix // Iteratively är ett ord, ignorera
    ABM also offers a high degree of flexibility where the model makes it easy to construct and inject new agents with different behavior, heuristics, and so on. This will be important both for the development team and the end user experience since this property will allow us to iteratively adapt the complexity of our simulation as the development process proceed, and then easily offer our users way of tweaking different behaviors. The ability to easily adjust the complexity of the model is highly valued by the development team as this allows us to adapt and make changes as needed during the course of the project. This is particularly important as the team has not previously worked on a project of this nature, and thus, flexibility serves as a safety net for any potential shortcomings in product planning. 

%% Felix
\subsection{Testing}
    Due to the challenging nature of validating and testing agent-based simulation, our main method of making sure our software is working correctly will be in the form in-house user testing. A set amount of hours will be allocated each week once testing becomes relevant where developers will explore and observe the simulation under different parameters. The goal of this will be to identify any faulty system behaviour or usability issues, and also gather valuable feedback on the overall design and functionality of the simulation.

%% Marcus
\subsection{Organisation}
    In order to have a clear organizational structure we decided to employ an interpretation of the \glossaryword{scrum}{scrum agile framework} \cite{scrum}. In scrum, the work is split into weekly partitions called sprints. Before each sprint there is a planning meeting in which you plan the upcoming sprint - what to do and who should do it. After the sprint, a sprint review is held to reflect about whether all goals were met. The sprints should be relatively short since the scrum framework is based around the idea of creating software through iterations, meaning new iterations should be produced at a regular pace. We have decided on one week long sprints, with a weekly demo meeting acting as our sprint review in which all members demonstrate their completed work during the past sprint. This also serves an additional purpose - sharing the progress between all members so everyone is on board with how far the software as a whole has evolved and opening up possibilities for input and discussion.

    After the demo meeting, a sprint planning will occur every week in order to assign tasks to members and plan the goals for the upcoming week. Each weekly sprint planning originates from a goal set for a longer time period which describes the next iteration of the software. The next iteration is collectively decided upon as a specification of requirements during a planning meeting. The planning meeting is centered around the monthly goals set in \fullref{time-plan}. We have also assigned a project leader responsible for taking this next iteration and splitting it up into tasks to be completed during the sprints, making sure there is a logical order of completion for the tasks.

    The aim of the combination of longer time frame iteration planning and short term sprint goals is to develop a fast-paced iterative software development environment where new functioning versions of the software are released at a regular interval. This makes sure the software is continuously developed in the right direction and splits the work into small manageable parts with a clear progression between them.