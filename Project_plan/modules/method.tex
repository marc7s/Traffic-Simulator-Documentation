%% Marcus
The simulation tool will be developed in \glossaryword{unity}{Unity}, a cross-platform game engine. The workflow we aim to implement is comprised of several distinct areas, each of which plays a crucial role in the overall development. Below follows a short description of each area and the method we have chosen to implement with an accompanying motivation. These are 1) Game Engine and Libraries, 2) Modeling, 3) Testing, and finally 4) Organisation. The chapter will then conclude with stating the criteria by which we will judge the success of the project. 

%% Felix
\subsection{Game Engine and Libraries}
    The simulation tool will be developed in \glossaryword{unity}{Unity}, a cross-platform game engine.
    Unity is a cross-platform game engine and development environment which comes with a plethora of useful tools for developing software that communicate with a 2D or 3D environment. It is currently the most used game engine, holding a market share of 38\% within the game engine market\cite{unity-market-share}. From initially being marketed as a highly accessible game engine, it has grown into a versatile tool that can be used for a wide range of applications. These include animation, simulation, VR, architectural visualisation and more. With the above in mind, together with the massive amount of high quality documentation available and high number of asset plugins available, we motivate Unity as the choice of engine to actualise the simulation.

%% Felix
\subsection{Modeling}
    We motivate our choice of an agent based approach by its ability to capture and convey complex behaviour that would otherwise have required highly complex mathematics. After we have configured the simulation environment, we only require the ability to decide and manipulate how the agents react to the it. This will be enough to allow us to capture an interesting emergent system that would otherwise require the use of complex differential equations if it were modeled from a macroscopic perspective.

    %% Felix 
    Our goal is to make a product that can easily convey both the statistical information of the simulation as well as the first-hand experience of how traffic actually behaves. This will be in the form of exploring the environment in real-time 3D. This further motivates our decision to go with an ABM approach. While ABM is classified as a microscopic model, it still allows for gathering data from each autonomous agent and aggregating it in the form of statistics. On the other hand, by rendering the simulation and each agent in real-time, it will allow the user to see the effects of the parameters they supplied for the environment. For example, this could be in the form of observing a crossing, or following one specific agent throughout its journey towards some destination.

    %% Felix 
    ABM also offers a high degree of flexibility where the model makes it easy to construct and inject new agents with different behaviors, heuristics, and so on. This will be important for both the development team and the final end user experience. The property will allow us to iteratively adapt the complexity of our simulation as the development process proceeds, and be easily offered to our users as a way of tweaking different behaviors. The ability to easily adjust the complexity of the model is highly valued by the development team as well, because it allows us to adapt and make changes as needed during the course of the project. It is particularly important to note that the team has not previously worked on a project of this nature, and thus, flexibility serves as a safety net for any potential shortcomings in the product planning.

\subsection{Version Control}
In order to collaborate, the project will be stored in a Git repository. This also allows for version control and the opportunity to revert to previous versions in the case of identification of errors. Since a Unity project does not consist of pure text or code files, additional steps have to be taken in order to avoid merge conflicts or other issues that can arise when collaborating in a version control system. Therefore each developer will have their own scene in Unity and updates to the project will mainly take place as changes to \glossaryword{prefab}{prefabs}, which are reusable composite objects that can be used as templates.

%% Felix
\subsection{Testing}
    Due to the challenging nature of validation and testing of agent-based simulations, our main method of making sure our software is working correctly will be in the form of in-house \glossaryword{user-testing}{user testing}. A set amount of hours will be allocated each week once testing becomes relevant, where developers will explore and observe the simulation under different parameters. The goal of this will be to identify any faulty system behaviour or usability issues, and also gather valuable feedback on the overall design and functionality of the simulation.

%% Marcus
\subsection{Organisation}
    In order to have a clear organizational structure we decided to employ an interpretation of the \glossaryword{scrum}{scrum agile framework} \cite{scrum}. In scrum, the work is split into weekly partitions called sprints. Before each sprint there is a planning meeting in which you plan the upcoming sprint - what to do and who should do it. After the sprint, a sprint review is held to reflect about whether all goals were met. The sprints should be relatively short as the scrum framework is based around the idea of creating software through iterations. This means new iterations should be produced at a regular pace. We have decided on one week long sprints, with a weekly demo meeting acting as our sprint review in which all members demonstrate their completed work during the past sprint. This also serves an additional purpose - sharing the progress between all members so everyone is on board with how far the software as a whole has evolved and opening up possibilities for input and discussion.

    After the demo meeting, sprint planning will occur every week in order to assign tasks to members and plan the goals for the upcoming week. Each weekly sprint planning originates from a goal set for a longer time period which describes the next iteration of the software. The next iteration is collectively decided upon as a specification of requirements during a planning meeting. The planning meeting is centered around the monthly goals set in \fullref{time-plan}. We have also assigned a project leader responsible for taking this next iteration and splitting it up into tasks to be completed during the sprints, making sure there is a logical order of completion for the tasks.

    The aim of combining the longer time frame iteration plan with the short term sprint goals is to develop a fast-paced iterative software development environment. This enables new functioning versions of the software to be released at a regular interval. This makes sure the software is continuously developed in the right direction and splits the work into small manageable parts with a clear progression between them.

    

\subsection{Criteria of success}
The success of the project will be analyzed in three dimensions: functionality, user-friendliness, and computation capacity. 

Functionality will be judged on how many meaningful and correctly functioning features our final simulation offers. The features need to be meaningful in the way of allowing the user to observe and gain insights of how different traffic flow set-ups produce interesting results depending on the supplied simulation parameters.

User-Friendliness will be analyzed on how easy it is for the user to understand the interface and interpret the produced statistics. The user should be able to set up simulations with ease and be able to easily extract insights from the results. Out of house user testing might be necessary for this, though this is currently not in the project plan. 

Computation capacity will measure how well the simulation can handle complex traffic scenarios and its ability to function under high computational workload. Different kind of stress tests will have to be constructed and carried out to make sure that the simulation is capable of handling a sufficient amount of agents to represent realistic scenarios. 

